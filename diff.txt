diff --git a/CRAN.md b/CRAN.md
index 3f2a6b8..8d8597c 100644
--- a/CRAN.md
+++ b/CRAN.md
@@ -5,11 +5,14 @@
 [x] Check version
 [x] Run tests with
     [x] winbuilder
+[ ] Rhub
     [x] valgrind
     [ ] rchk
 [x] Check coverage
 [ ] Check build user
 
+
+
 ## Submission Notes:
 
 This is a minor release primarily intended
diff --git a/DESCRIPTION b/DESCRIPTION
index 7e6644b..a1b0179 100644
--- a/DESCRIPTION
+++ b/DESCRIPTION
@@ -3,7 +3,7 @@ Title: Trust, but Verify
 Description: Declarative template-based framework for verifying that objects
   meet structural requirements, and auto-composing error messages when they do
   not.
-Version: 0.2.19
+Version: 0.2.19.9000
 Authors@R: c(
     person("Brodie", "Gaslam", email="brodie.gaslam@yahoo.com",
     role=c("aut", "cre")),
diff --git a/NEWS.md b/NEWS.md
index 33beaf2..f6fd7c1 100644
--- a/NEWS.md
+++ b/NEWS.md
@@ -1,3 +1,9 @@
+## 0.2.20
+
+* Fix non C API access.
+* Related to the above, `abstract.ts` now creates an R object with a "tsp_vetr"
+  attribute to replace the "tsp" attribute in the template (see `?abstract`).
+
 ## 0.2.19
 
 * Fix non C API access.
diff --git a/R/abstract.R b/R/abstract.R
index d9b8956..c132fa5 100644
--- a/R/abstract.R
+++ b/R/abstract.R
@@ -40,15 +40,16 @@
 #'
 #' @section Time Series:
 #'
-#' \code{\link{alike}} will treat time series parameter components with zero in
-#' them as wildcards.  This function allows you to create these wild card time
-#' series attributes since R does not allow direct creation/modification of
-#' \code{ts} attributes with zero values.
-#'
-#' Make sure you do not try to use the templates you create with this for
-#' anything other than as \code{\link{alike}} templates since the result is
-#' likely undefined given R expects non zero values for the \code{ts}
-#' attribute and attempts to prevent such attributes.
+#' `abstract` replaces the "tsp" attribute with a "tsp_vetr" attribute with the
+#' components specified in `what` set to zero.  \code{\link{alike}} will
+#' treat it as a "tsp" attribute except that the zero components become
+#' wildcards.  If you manually create a template object with both
+#' "tsp" and "tsp_vetr" attributes, "tsp_vetr" is treated as a regular
+#' attribute.  `vetr` does not consider whether the "ts" class is also set
+#' when attributing special semantics to the "tsp".  The "tsp_vetr" attribute is
+#' required because R does not permit 0 values in "tsp".  Prior to R4.6.0 and
+#' `vetr` 2.20, `vetr` constructed a "tsp" attribute with zeroes, but it no
+#' longer does that.
 #'
 #' @export
 #' @param x the object to abstract
@@ -175,8 +176,13 @@ abstract.ts <- function(x, what=c("start", "end", "frequency"), ...) {
   attr(x, "tsp") <- NULL
   x <- abstract.default(x, ...)
 
+  # Set the wildcard values to zero and store as "tsp_vetr" attribute
+  # (not "tsp") since R validates tsp and rejects zero frequency.
+  # The C comparison code recognizes both "tsp" and "tsp_vetr" as
+  # time series template attributes.
   tsp[match(unique(what), what.valid)] <- 0
-  .Call(VALC_abstract_ts, x, tsp)
+  attr(x, "tsp_vetr") <- tsp
+  x
 }
 #' Set Element to NULL Without Removing It
 #'
diff --git a/src/alike.h b/src/alike.h
index df77c96..c1b7579 100644
--- a/src/alike.h
+++ b/src/alike.h
@@ -230,7 +230,6 @@ Go to <https://www.r-project.org/Licenses/GPL-2> for a copy of the license.
     struct ALIKEC_res res, SEXP call, struct VALC_settings set
   );
   SEXP ALIKEC_class(SEXP obj, SEXP class);
-  SEXP ALIKEC_abstract_ts(SEXP x, SEXP what);
   int ALIKEC_env_track(SEXP env, struct ALIKEC_env_track * envs, int env_limit);
   SEXP ALIKEC_env_track_test(SEXP env, SEXP stack_size_init, SEXP env_limit);
   struct ALIKEC_env_track * ALIKEC_env_set_create(
diff --git a/src/attr.c b/src/attr.c
index e58a32a..e5dd92d 100644
--- a/src/attr.c
+++ b/src/attr.c
@@ -17,6 +17,7 @@ Go to <https://www.r-project.org/Licenses/GPL-2> for a copy of the license.
 */
 
 #include "alike.h"
+#include "backports.h"
 /*
  * used to take res_sub as input, but we got rid of that when we rationalized
  * most of our result structs to be ALIKEC_res
@@ -257,8 +258,10 @@ struct ALIKEC_res ALIKEC_compare_class(
   // Make sure class attributes are alike
 
   if(res.success) {
-    res =
-      ALIKEC_alike_attr(ATTRIB(target), ATTRIB(current), "class", set);
+    SEXP tar_class_attrs = PROTECT(R_getAttributes(target));
+    SEXP cur_class_attrs = PROTECT(R_getAttributes(current));
+    res = ALIKEC_alike_attr(tar_class_attrs, cur_class_attrs, "class", set);
+    UNPROTECT(2);
     PROTECT(res.wrap);
   } else PROTECT(R_NilValue);
   res.dat.df = is_df;
@@ -615,34 +618,38 @@ struct ALIKEC_res ALIKEC_compare_dimnames(
     will the checking all attributes; also, do we really need to check whether
     dimnames has attributes other than names?*/
 
-    SEXP prim_attr = ATTRIB(prim), sec_attr = ATTRIB(sec);
+    SEXP prim_attr_list = PROTECT(R_getAttributes(prim));
+    SEXP sec_attr_list = PROTECT(R_getAttributes(sec));
+    SEXP prim_attr_sort = PROTECT(ALIKEC_list_as_sorted_vec(prim_attr_list));
+    SEXP sec_attr_sort = PROTECT(ALIKEC_list_as_sorted_vec(sec_attr_list));
+    SEXP prim_attr_names = PROTECT(getAttrib(prim_attr_sort, R_NamesSymbol));
+    SEXP sec_attr_names = PROTECT(getAttrib(sec_attr_sort, R_NamesSymbol));
+
+    R_xlen_t prim_attr_count = XLENGTH(prim_attr_sort);
+    R_xlen_t sec_attr_count = XLENGTH(sec_attr_sort);
 
     /*
     Check that all `dimnames` attributes other than `names` that are both in
-    target and current are alike; this is also a double loop that could be
-    optimized; can't do the normal check because we need to leave out the
-    `names` attribute from the comparison.  This could be simplified if we had
-    an attribute comparison function that could skip a particular attribute.
+    target and current are alike; using sorted vectors for O(n) comparison.
     */
 
-    SEXP prim_attr_cpy, sec_attr_cpy;
-    for(
-      prim_attr_cpy = prim_attr; prim_attr_cpy != R_NilValue;
-      prim_attr_cpy = CDR(prim_attr_cpy)
-    ) {
-      SEXP prim_tag_symb = TAG(prim_attr_cpy);
-      const char * prim_tag = CHAR(PRINTNAME(prim_tag_symb));
-      int do_continue = 0;
+    R_xlen_t pi = 0, si = 0;
+    for(pi = 0; pi < prim_attr_count; ++pi) {
+      const char * prim_tag = CHAR(STRING_ELT(prim_attr_names, pi));
+
       // skip names attribute
-      if(prim_tag_symb == R_NamesSymbol) continue;
-      for(
-        sec_attr_cpy = sec_attr; sec_attr_cpy != R_NilValue;
-        sec_attr_cpy = CDR(sec_attr_cpy)
-      ) {
-        if(prim_tag_symb == TAG(sec_attr_cpy)) {
-          res = ALIKEC_alike_internal(
-            CAR(prim_attr_cpy), CAR(sec_attr_cpy), set
-          );
+      if(strcmp(prim_tag, "names") == 0) continue;
+
+      // Advance sec index to find matching tag or determine it's missing
+      int do_continue = 0;
+      while(si < sec_attr_count) {
+        const char * sec_tag = CHAR(STRING_ELT(sec_attr_names, si));
+        int cmp = strcmp(prim_tag, sec_tag);
+        if(cmp == 0) {
+          // Found matching tag, compare values
+          SEXP prim_val = VECTOR_ELT(prim_attr_sort, pi);
+          SEXP sec_val = VECTOR_ELT(sec_attr_sort, si);
+          res = ALIKEC_alike_internal(prim_val, sec_val, set);
           REPROTECT(res.wrap, ipx);
 
           if(!res.success) {
@@ -654,19 +661,28 @@ struct ALIKEC_res ALIKEC_compare_dimnames(
             break;
           } else {
             do_continue = 1;
+            si++;
             break;
-      } } }
+          }
+        } else if(cmp < 0) {
+          // prim_tag < sec_tag: prim_tag is missing from sec
+          break;
+        } else {
+          // sec_tag < prim_tag: skip extra attr in sec
+          si++;
+        }
+      }
       if(do_continue == 1) continue;    // success, next outer loop
       else if(do_continue == 2) break;  // failure, exit outer
-
-      // missing attribute
-
+      // prim_tag was not found
       res.success = 0;
       res.dat.strings.tar_pre = "not be";
       res.dat.strings.target[1] = "missing";
       res.dat.strings.current[1] = ""; // gcc-10
       REPROTECT(res.wrap = ALIKEC_compare_dimnames_wrap(prim_tag), ipx);
+      break;
     }
+    UNPROTECT(6);
     // Compare actual dimnames attr, note that zero length primary attribute
     // matches any sec attribute
 
@@ -941,14 +957,11 @@ struct ALIKEC_res ALIKEC_compare_attributes_internal(
 ) {
   struct ALIKEC_res res_attr = ALIKEC_res_init();
 
-  // Note we don't protect these because target and curent should come in
-  // protected so every SEXP under them should also be protected
-
   SEXP tar_attr, cur_attr;
   int rev = 0, is_df = 0;
 
-  tar_attr = ATTRIB(target);
-  cur_attr = ATTRIB(current);
+  tar_attr = PROTECT(R_getAttributes(target));
+  cur_attr = PROTECT(R_getAttributes(current));
 
   if(tar_attr == R_NilValue && cur_attr == R_NilValue) return res_attr;
   /*
@@ -998,6 +1011,7 @@ struct ALIKEC_res ALIKEC_compare_attributes_internal(
   R_xlen_t i, j;
   i = 0; j = 0;
   int is_names = 0;
+  int tar_has_tsp = 0;
 
   // A bit of a weird loop, we walk up through both sorted lists depending on
   // what attributes are missing from either list.
@@ -1023,6 +1037,12 @@ struct ALIKEC_res ALIKEC_compare_attributes_internal(
       );
       // nocov end
 
+    // Handle the special tsp_vetr attribute (see `abstract`).  If it is present
+    // in the template, convert it to "tsp".
+
+    if(!strcmp(tar_tag, "tsp")) tar_has_tsp = 1;  // sorted so first
+    if(!strcmp(tar_tag, "tsp_vetr") && !tar_has_tsp) tar_tag = "tsp";
+
     // Get elements to check; we use dummy NULL values if we're at the end of
     // the vectors to allow for dummy checks
 
@@ -1241,7 +1261,7 @@ struct ALIKEC_res ALIKEC_compare_attributes_internal(
       break;
   } }
   res_attr.dat.df = is_df;
-  UNPROTECT(6);
+  UNPROTECT(8);
   return res_attr;
 }
 /*-----------------------------------------------------------------------------\
diff --git a/src/backports.c b/src/backports.c
new file mode 100644
index 0000000..edd5670
--- /dev/null
+++ b/src/backports.c
@@ -0,0 +1,101 @@
+/*
+Copyright (C) Brodie Gaslam
+
+This file is part of "vetr - Trust, but Verify"
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Go to <https://www.r-project.org/Licenses/GPL-2> for a copy of the license.
+
+This file contains code copied from the R's Writing R Extensions manual and from
+the R sources.  Original copyright notices follow.
+*/
+/*
+ *  R : A Computer Language for Statistical Data Analysis
+ *  Copyright (C) 1999--2025  The R Core Team.
+ *  Copyright (C) 1995, 1996  Robert Gentleman and Ross Ihaka
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, a copy is available at
+ *  https://www.R-project.org/Licenses/
+ */
+/*
+ * C level equivalent of `attributes()`, returns NULL or the attributes as a
+ * VECSXP.
+ *
+ * R_getAttributes was introduced in R 4.6.0. This backport uses ATTRIB which is
+ * still available in earlier R versions.
+ *
+ * The return value MUST BE PROTECTED.
+ *
+ * This code is from ~r89313
+ */
+
+#include <Rinternals.h>
+#include <Rversion.h>
+
+#if R_VERSION < R_Version(4, 6, 0)
+SEXP R_getAttributes(SEXP x)
+{
+    if (TYPEOF(x) == ENVSXP)
+	R_CheckStack(); /* in case attributes might lead to a cycle */
+
+    SEXP attrs = ATTRIB(x), namesattr;
+    int nvalues = length(attrs);
+    if (isList(x)) {
+	namesattr = getAttrib(x, R_NamesSymbol);
+	if (namesattr != R_NilValue)
+	    nvalues++;
+    } else
+	namesattr = R_NilValue;
+    /* FIXME */
+    if (nvalues <= 0)
+	return R_NilValue;
+    /* FIXME */
+    SEXP value, names;
+    PROTECT(namesattr);
+    PROTECT(value = allocVector(VECSXP, nvalues));
+    PROTECT(names = allocVector(STRSXP, nvalues));
+    nvalues = 0;
+    if (namesattr != R_NilValue) {
+	SET_VECTOR_ELT(value, nvalues, namesattr);
+	SET_STRING_ELT(names, nvalues, PRINTNAME(R_NamesSymbol));
+	nvalues++;
+    }
+    while (attrs != R_NilValue) {
+	SEXP tag = TAG(attrs);
+	if (TYPEOF(tag) == SYMSXP) {
+	    SET_VECTOR_ELT(value, nvalues, getAttrib(x, tag));
+	    SET_STRING_ELT(names, nvalues, PRINTNAME(tag));
+	}
+	else { // empty tag, hence name = ""
+	    MARK_NOT_MUTABLE(CAR(attrs));
+	    SET_VECTOR_ELT(value, nvalues, CAR(attrs));
+	    SET_STRING_ELT(names, nvalues, R_BlankString);
+	}
+	attrs = CDR(attrs);
+	nvalues++;
+    }
+    setAttrib(value, R_NamesSymbol, names);
+    UNPROTECT(3);
+    return value;
+}
+#endif
diff --git a/src/backports.h b/src/backports.h
index b39073e..fce942b 100644
--- a/src/backports.h
+++ b/src/backports.h
@@ -15,8 +15,8 @@ GNU General Public License for more details.
 
 Go to <https://www.r-project.org/Licenses/GPL-2> for a copy of the license.
 
-This file contains code copied from the R's Writing R Extensions manual.
-Original copyright notices follow.
+This file contains code copied from the R's Writing R Extensions manual and from
+the R sources.  Original copyright notices follow.
 */
 /*
  *  R : A Computer Language for Statistical Data Analysis
@@ -62,3 +62,7 @@ static SEXP Rf_allocLang(int n)
 # define R_ParentEnv(x) ENCLOS(x)
 
 #endif
+
+#if R_VERSION < R_Version(4, 6, 0)
+SEXP R_getAttributes(SEXP x);
+#endif
diff --git a/src/init.c b/src/init.c
index d0b1cd0..8eb772a 100644
--- a/src/init.c
+++ b/src/init.c
@@ -60,7 +60,6 @@ R_CallMethodDef callMethods[] = {
   {"pad", (DL_FUNC) &ALIKEC_pad_ext, 3},
   {"pad_or_quote", (DL_FUNC) &ALIKEC_pad_or_quote_ext, 3},
   {"match_call", (DL_FUNC) &ALIKEC_match_call, 3},
-  {"abstract_ts", (DL_FUNC) &ALIKEC_abstract_ts, 2},
   {"env_track", (DL_FUNC) &ALIKEC_env_track_test, 3},
   {"msg_sort", (DL_FUNC) &ALIKEC_sort_msg_ext, 1},
   {"msg_merge", (DL_FUNC) &ALIKEC_merge_msg_ext, 1},
diff --git a/src/misc-alike.c b/src/misc-alike.c
index c00fa60..6507b87 100644
--- a/src/misc-alike.c
+++ b/src/misc-alike.c
@@ -19,6 +19,7 @@ Go to <https://www.r-project.org/Licenses/GPL-2> for a copy of the license.
 #include "alike.h"
 #include "pfhash.h"
 #include <time.h>
+#include "backports.h"
 
 // - Helper Functions ----------------------------------------------------------
 
@@ -61,41 +62,7 @@ SEXP ALIKEC_getopt(const char * opt) {
   return opt_val;
 }
 // - Abstraction ---------------------------------------------------------------
-/*
-sets the select `tsp` values to zero
-*/
-SEXP ALIKEC_abstract_ts(SEXP x, SEXP attr) {
-  if(TYPEOF(attr) != REALSXP || XLENGTH(attr) != 3) {
-    // nocov start
-    error("Internal Error: incorrect format for tsp attr, contact maintainer");
-    // nocov end
-  }
-  SEXP x_cp = PROTECT(duplicate(x));
-
-  // Get to last attribute, and make sure tsp is not set
 
-  SEXP attrs = ATTRIB(x_cp), attrs_cpy, attrs_last = R_NilValue;
-  for(attrs_cpy = attrs; attrs_cpy != R_NilValue; attrs_cpy = CDR(attrs_cpy)) {
-    attrs_last = attrs_cpy;
-    if(TAG(attrs_cpy) == R_TspSymbol) break;
-  }
-  if(attrs_cpy != R_NilValue) {
-    // nocov start
-    error("Internal Error: object already has a `tsp` attribute");
-    // nocov end
-  }
-  if(attrs_last == R_NilValue) {
-    // nocov start
-    error("Internal Error: failed finding last attribute when adding tsp");
-    // nocov end
-  }
-  // Illegally append non-kosher tsp attribute
-
-  SETCDR(attrs_last, list1(attr));
-  SET_TAG(CDR(attrs_last), R_TspSymbol);
-  UNPROTECT(1);
-  return x_cp;
-}
 /*
 Run deparse command and return character vector with results
 
@@ -574,15 +541,15 @@ SEXP ALIKEC_is_dfish_ext(SEXP obj) {
   return ScalarLogical(ALIKEC_is_dfish(obj));
 }
 /*
- * Starts with a pair list, and returns it as a VECSXP sorted by tag
+ * Takes a named vector list (VECSXP, e.g. from R_getAttributes) and returns
+ * it sorted by name.
  *
- * Note that this uses `qsort` so the sort is not stable on ties.  Our primary
- * use case is to compare attributes where there should not be duplicate tas in
- * the attribute LISTSXP, so that should not matter.
+ * This function expects input from R_getAttributes which returns a named
+ * VECSXP. Input must be NULL or VECSXP.
  *
- * Not sure if there is a way to sort a SEXP VECSXP in place, but seems pretty
- * dangerous so we'll settle for the intermediate approach where we sort the
- * indeces and tag names.
+ * Note that this uses `qsort` so the sort is not stable on ties. Our primary
+ * use case is to compare attributes where there should not be duplicate names,
+ * so that should not matter.
  */
 
 struct chr_idx {SEXP name; SEXP val; R_xlen_t idx;};
@@ -595,35 +562,36 @@ static int cmpfun (const void * p, const void * q) {
   return(strcmp(a_chr, b_chr));
 }
 SEXP ALIKEC_list_as_sorted_vec(SEXP x) {
-  if(x != R_NilValue && TYPEOF(x) != LISTSXP)
-    error("Internal Error: input should be NULL or a LISTSXP"); // nocov
-
   SEXP res, res_nm;
 
   if(x == R_NilValue) {
-    res = PROTECT(PROTECT(allocVector(VECSXP, 0)));
-  } else {
-    SEXP x_el = x;
-    R_xlen_t x_len = xlength(x);
-
-    // Fill our sort buffer and transfer everything to VECSXP
+    res_nm = PROTECT(allocVector(STRSXP, 0));
+    res = PROTECT(PROTECT(allocVector(VECSXP, 0))); // stack bal
+    setAttrib(res, R_NamesSymbol, res_nm);
+  } else if(TYPEOF(x) == VECSXP) {
+    R_xlen_t x_len = XLENGTH(x);
+    SEXP x_names = PROTECT(getAttrib(x, R_NamesSymbol));
 
+    // Fill our sort buffer
     struct chr_idx * sort_buff =
       (struct chr_idx *) R_alloc((size_t) x_len, sizeof(struct chr_idx));
 
     for(R_xlen_t i = 0; i < x_len; ++i) {
-      SEXP nm = TAG(x_el) == R_NilValue ? R_BlankString : PRINTNAME(TAG(x_el));
+      SEXP nm;
+      if(x_names == R_NilValue || TYPEOF(x_names) != STRSXP) {
+        nm = R_BlankString;
+      } else {
+        nm = STRING_ELT(x_names, i);
+        if(nm == NA_STRING) nm = R_BlankString;
+      }
       *(sort_buff + i) = (struct chr_idx) {
-        .name = nm, .val = CAR(x_el), .idx = i
+        .name = nm, .val = VECTOR_ELT(x, i), .idx = i
       };
-      x_el = CDR(x_el);
     }
     // Sort the buffer and reorder the vectors
 
     qsort(sort_buff, (size_t) x_len, sizeof(struct chr_idx), cmpfun);
 
-    // `head` holds the data at the current spot that needs to be overwritten
-
     res = PROTECT(allocVector(VECSXP, x_len));
     res_nm = PROTECT(allocVector(STRSXP, x_len));
 
@@ -633,7 +601,9 @@ SEXP ALIKEC_list_as_sorted_vec(SEXP x) {
       SET_STRING_ELT(res_nm, i, tar.name);
     }
     setAttrib(res, R_NamesSymbol, res_nm);
+  } else {
+    error("Internal Error: input should be NULL or VECSXP"); // nocov
   }
-  UNPROTECT(2);
+  UNPROTECT(3);
   return res;
 }
diff --git a/tests/unitizer/abstract.R b/tests/unitizer/abstract.R
index fcc4e99..1fee979 100644
--- a/tests/unitizer/abstract.R
+++ b/tests/unitizer/abstract.R
@@ -39,16 +39,30 @@ unitizer_sect("Standard Methods", {
 })
 unitizer_sect("Time Series", {
   y <- ts(runif(12), start=1970, frequency=12)
-  attr(abstract(y), "tsp")
-  attr(abstract(y, "start"), "tsp")
-  attr(abstract(y, "end"), "tsp")
-  attr(abstract(y, "frequency"), "tsp")
-  attr(abstract(y, c("start", "frequency")), "tsp")
+  attributes(abstract(y))
+  attributes(abstract(y, "start"))
+  attributes(abstract(y, "end"))
+  attributes(abstract(y, "frequency"))
+  attributes(abstract(y, c("start", "frequency")))
+
+  y2 <- ts(numeric(12), start=1960, frequency=12)
+  alike(abstract(y, c("start", "end")), y2)
+  alike(abstract(y, c("start")), y2)
+
+  y2 <- ts(numeric(12), start=1960, frequency=13)
+  alike(abstract(y, c("start", "end")), y2)
 
   # Errors
 
   abstract(y, "boom")
   vetr:::abstract.ts(1:12)
+
+  # Test what happens with both "tsp" and "tsp_vetr"
+  y.abs <- abstract(y)
+  alike(y.abs, y)
+  alike(y, y.abs)
+  # ... should have attribute "tsp", see ?abstract, str(y.abs)
+  alike(y.abs, y.abs)
 })
 unitizer_sect("s4", {
   ## s4 objects are unaffected
diff --git a/tests/unitizer/abstract.unitizer/data.rds b/tests/unitizer/abstract.unitizer/data.rds
index 803d57a..5930eac 100644
Binary files a/tests/unitizer/abstract.unitizer/data.rds and b/tests/unitizer/abstract.unitizer/data.rds differ
